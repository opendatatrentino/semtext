/*
 * Copyright 2015 Trento Rise.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package eu.trentorise.opendata.semantics.nlp.model;

import com.google.common.base.Preconditions;
import static com.google.common.base.Preconditions.checkNotNull;
import com.google.common.base.Strings;
import static eu.trentorise.opendata.commons.OdtUtils.checkNotEmpty;
import java.util.List;
import javax.annotation.Nullable;

public class Checker {

    /**
     * Tolerance for probabilities
     */
    public static final double TOLERANCE = 0.001;

    /**
     * Checks that the provided couple meaning status / selected meaning makes
     * sense.
     */
    public static void checkMeaningStatus(MeaningStatus meaningStatus, @Nullable Meaning selectedMeaning) {
        if (MeaningStatus.SELECTED.equals(meaningStatus)
                || MeaningStatus.REVIEWED.equals(meaningStatus)) {
            checkNotNull(selectedMeaning, "Selected meaning can't be null when status is " + meaningStatus);
            checkNotEmpty(selectedMeaning.getId(), "Selected meaning must have a valid id when status is " + meaningStatus);
        } else {
            if (selectedMeaning != null) {
                throw new IllegalArgumentException("Selected meanining must be null when meaning status is " + meaningStatus + ". Found instead meaning " + selectedMeaning);
            }
        }
    }

    public static void checkMeaning(Meaning m) {
        checkScore(m.getProbability());
        checkNotNull(m.getName(), "Invalid name!");
    }

    public static void checkScore(double score) {
        double prec = TOLERANCE;
        if (score < -prec || score > 1.0 + prec) {
            throw new IllegalArgumentException("Score " + score + " exceeds bounds [" + (-prec) + ", " + 1.0 + prec + "].");
        }
    }

    /**
     * getStart must be less or equal than endoffset and they must be both
     * greater or equal than 0
     *
     */
    public static void checkSpan(int startOffset, int endOffset, String prependedErrorMessage) {
        prependedErrorMessage = Strings.nullToEmpty(prependedErrorMessage);
        Preconditions.checkArgument(startOffset < 0
                || endOffset < 0
                || endOffset < startOffset,
                prependedErrorMessage, startOffset, endOffset);
    }

    /**
     *
     * Checks spans are all be valid spans (see {@link #checkSpan(int, int) }
     * and are be non-overlapping (a span getEnd offset may coincide with next
     * span getStart offset). Spans must be contained within startOffset and
     * endOffset (last span getEnd offset may coincide with endOffset).
     *
     * @param prependedErrorMessage This error message will be prepended to a
     * more specific one generated by this method.
     *
     */
    public static void checkSpans(List<? extends Span> spans, int startOffset, int endOffset, String prependedErrorMessage) {

        prependedErrorMessage = Strings.nullToEmpty(prependedErrorMessage);

        checkNotNull(spans);
        checkSpan(startOffset, endOffset, prependedErrorMessage);

        // check containment        
        if (!spans.isEmpty()) {
            int lowerBound = spans.get(0).getStart();
            int upperBound = spans.get(spans.size() - 1).getEnd();
            if (lowerBound < startOffset
                    || upperBound > endOffset) {
                throw new IllegalArgumentException(prependedErrorMessage + " -- Detailed reason: Provided spans exceed container span! Expected: [" + startOffset + "," + endOffset + "] - Found: [" + lowerBound + "," + upperBound + "]");
            }
        }

        // check overlaps
        @Nullable
        Span lastSpan = null;
        for (Span span : spans) {
            checkSpan(span.getStart(), span.getEnd(), prependedErrorMessage);
            if (lastSpan != null) {
                if (lastSpan.getEnd() > span.getStart()) {
                    throw new IllegalArgumentException(prependedErrorMessage + " -- Found overlapping span! Span " + lastSpan + " overlaps with span " + span);
                }
                lastSpan = span;
            }
        }

    }

}
